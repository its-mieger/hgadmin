#! /usr/bin/env python

import sys, os, re

def fail(message):
    sys.stderr.write("mercurial-server: %s\n" % message)
    sys.exit(-1)

def extractuser():
    return sys.argv[1]

def sanitize_path(path):
    path = path.strip()
    path = path.strip('"')
    path = os.path.abspath(path)
    if path.find('"') != -1 or path.find('/.') != -1 or os.sep != '/':
        fail("invalid repository path")
    return path

def is_managed_path(path):
    return os.access(path + '/.hg/ADMINISTRATED_BY_HGADMIN', os.F_OK)

def parse_cmd():
    origcmd =  os.environ.get('SSH_ORIGINAL_COMMAND', None)
    if origcmd == None:
        fail("started directly")

    match_serve  = re.match('^hg -R (.*) serve --stdio$', origcmd)
    match_init = re.match('^hg init (.*)$', origcmd)

    if not match_init and not match_serve:
        fail("invalid command")
    
    if match_serve:
        cmd = "serve"
        repo = match_serve.group(1)
    elif match_init:
        cmd = "create"
        repo = match_init.group(1)
    else:
        fail("internal error")
    repo = sanitize_path(repo)
    return (cmd, repo)
    
def allow_access(repo, user, access):
    repo = hg.repository(ui.ui(), repo)
    denyread   = [ x.strip() for x in ui.config("web", "deny_read")  .split(',') ]
    allowread  = [ x.strip() for x in ui.config("web", "allow_read") .split(',') ]
    denywrite  = [ x.strip() for x in ui.config("web", "deny_write") .split(',') ]
    allowwrite = [ x.strip() for x in ui.config("web", "allow_write").split(',') ]
    if access == 'read':
        if denyread == ['*'] or user in denyread:
            return False
        if allowread == ['*'] or user in allowread:
            return True
        return False
    elif access == 'write':
        if denywrite == ['*'] or user in denywrite:
            return False
        if allowwrite == ['*'] or user in allowwrite:
            return True
        return False
    else:
        return False

def create_impl(user, repo):
    fail("not implemented yet")
    import site
    homedir = os.path.dirname(os.path.dirname(sys.argv[0]))
    
    site.addsitedir(homedir+'/scripts/src')
    import parse_allconfigs, access

    conf = parse_allconfigs.parse_allconfigs(homedir)
    if not user in conf['userlist']:
        fail("unknown user")
    if is_managed_path(repo):
        fail("path already contains managed repository")
    if not access.validate_path(targetrepo) or not repo.is_managed_repo(targetrepo, conf['confdict']['reporoot']):
        fail("invalid path")
    allow_create = access.allow("create", user, repo, conf['accessdict'], conf['groupdict'])
    if not allow_create:
        fail("access denied")
    dispatch.dispatch(request(['init', targetrepo]))
    # FIXME: hgrc generieren und managed-by-datei dazu

def serve_impl(user, repo):
    if not is_managed_path(repo):
        fail("path contains no managed repository")
    from mercurial import demandimport; demandimport.enable()
    from mercurial import dispatch, hg, ui
    try:
        request = dispatch.request
    except AttributeError:
        request = list
    if not allow_access(repo, user, "read"):
        fail("invalid privilege")
    rqlist = ['-R', targetrepo, 'serve', '--stdio']
    if not allow_access(repo, user, "write"):
        rqlist += ['--config', 'hooks.prechangegroup=false', '--config', 'hooks.pretxnchangegroup=false']
    dispatch.dispatch(request(rqlist))

def main():
    user = extractuser()
    cmd, repo = parse_cmd()
    if cmd == "serve":
        serve_impl(user,repo)
    elif cmd == "create":
        create_impl(user,repo)
    else:
        fail("invalid command")

if __name__ == "main":
    main()

# enable importing on demand to reduce startup time

import sys, os, site, re

user = sys.argv[1]
homedir = os.path.dirname(os.path.dirname(sys.argv[0]))

site.addsitedir(homedir+'/scripts/src')
import parse_allconfigs, access

conf = parse_allconfigs.parse_allconfigs(homedir)
if not user in conf['userlist']:
    fail("unknown user")


print repr(targetrepo)

targetrepo = access.sanitize_path(targetrepo)

if not access.validate_path(targetrepo) or not repo.is_managed_repo(targetrepo, conf['confdict']['reporoot']):
    fail("invalid path")

if match_serve:
    allow_write = repo.allow_writeaccess(targetrepo, user)
    allow_read = repo.allow_readaccess(targetrepo, user)
    if allow_write:
        dispatch.dispatch(request(['-R', targetrepo, 'serve', '--stdio']))
    elif allow_read:
        dispatch.dispatch(request(['-R', targetrepo, 'serve', \
                    '--stdio', '--config', 'hooks.prechangegroup=false', \
                    '--config', 'hooks.pretxnchangegroup=false']))
    else:
        fail("access denied")
elif match_init:
    allow_create = access.allow("create", user, targetrepo, conf['accessdict'], conf['groupdict'])
    if allow_create:
         dispatch.dispatch(request(['init', targetrepo]))
    else:
        fail("access denied")
else:
    fail("internal error")
    
