#! /usr/bin/env python

import ConfigParser, string, sys, os, re, subprocess
from mercurial import ui, hg, dispatch

try:
    request = dispatch.request
except AttributeError:
    request = list 

# directory where hgadmin searches for its configuration
BASEDIR='~/hgadmin'

def usage(name):
    print """usage: 
%s [--confdir DIR] mkrepo USER PATH 
  creates repository at PATH, if USER is
  allowed. PATH is relative to configured repo directory.
%s [--confdir DIR] updateauth
  updates authorization information in the managed repositories,
  regenerates authorized_keys file etc
%s [--confdir DIR] verify
  reads in configuration and verifies its correctness (giving error messages)
%s [--confdir DIR] accesscheck ACCESSTYPE USER PATH
  prints TRUE if access ACCESSTYPE on PATH is allowed to USER, else FALSE
%s [--confdir DIR] getpattern PATH
  prints the pattern from the configuration that matches PATH
The configuration directory defaults to "~/hgadmin", which can be overridden 
by setting the environment variable "HGADMIN-CONFREPO" or using the "--confdir" option.
""" % (name, name, name, name, name)

config = None
confError = False

def main():
    global config
    x = BASEDIR
    x = os.getenv("HGADMIN-CONFREPO", x)
    if len(sys.argv) >= 3 and sys.argv[1] == "--confdir":
        x = sys.argv[2]
        del sys.argv[2]
        del sys.argv[1]
    config = parse_config(os.path.expanduser(x))
    debug("config: "+ repr(config))
    if len(sys.argv) == 4 and sys.argv[1] == "mkrepo":
        gen_repo(sys.argv[2], sys.argv[3])
        exit(0)
    elif len(sys.argv) == 2 and sys.argv[1] == "updateauth":
        update_auth()
        exit(0)
    elif len(sys.argv) == 2 and sys.argv[1] == "verify":
        if confError:
            exit(1)
        exit(0)
    elif len(sys.argv) == 5 and sys.argv[1] == "accesscheck":
        flag, p = sanitize_path(sys.argv[4])
        if flag:
            print allow_access(sys.argv[2], sys.argv[3], p)
        else:
            print False
        exit(0)  
    elif len(sys.argv) == 3 and sys.argv[1] == "getpattern":
        flag, p = sanitize_path(sys.argv[2])
        if flag:
            print repr(find_matching_repopat(p))
        else:
            print False
        exit(0)  
    else:
        usage(sys.argv[0])
        exit(1)

def fail(msg):
    message(msg, "failure")
    exit(1)

def message(msg, messagelevel="info"):
    print messagelevel, ":", msg

def debug(msg):
    message(msg, "debug")
    #pass

def warn(msg):
    message(msg, "warning")

def gen_repo(user, unsanitized_repopath):
    path_ok, sanitized_path = sanitize_path(unsanitized_repopath)
    if not path_ok:
        fail("invalid path")
    if not user in config.userlist:
        fail("unknown user")
    if not allow_access("create", user, sanitized_path):
        fail("access denied")
    dispatch.dispatch(request(['init', sanitized_path]))
    gen_hgrc(sanitized_path)
    x = open(sanitized_path+'/.hg/ADMINISTRATED_BY_HGADMIN', "w")
    x.write("foo")
    x.close()
    debug("now creating repo at " + repr(sanitized_path))

def update_auth():
    repolist = list_all_repos()
    for repo in repolist:
        gen_hgrc(repo)
    gen_authkeys()
    #gen_htaccess()

def list_all_repos():
    repolist = []
    f = config.paths['repopath']
    for root, dirs, files in os.walk(f, topdown=True):
        debug("walking: " + repr(root))
        if is_managed_repo(root, isAbs=True):
            debug("found: " + repr(root))
            repolist.append(root)
        if '.hg' in dirs: 
            dirs.remove('.hg')
    debug("all repos: " + repr(repolist))
    return repolist

def is_managed_repo(repo, isAbs=False):
    if isAbs:
        repopath = repo
    else:
        root = config.paths['repopath']
        repopath = root + '/' + repo
    x = os.access(repopath + '/.hg/ADMINISTRATED_BY_HGADMIN', os.F_OK)
    debug("is:managed_repopath" + repr(repopath) + " : " + repr(x))
    return x

class confobj: # object to save configuration settings
    def __init__(self):
        self.userlist = None
        self.groupdict = None
        self.accessdict = None
        self.paths = None
    def __repr__(self):
        return "config:\n" \
            + "  userlist: "   + repr(self.userlist) + "\n" \
            + "  groupdict: "  + repr(self.groupdict) + "\n" \
            + "  accessdict: " + repr(self.accessdict) + "\n" \
            + "  paths: "      + repr(self.paths) + "\n" 


def parse_config(confdir):
    global confError

    def _valid_name(name):
        validchars = string.letters + string.digits + '_-+&'
        for c in name:
            if not c in validchars:
                return False
        return True
    
    def _valid_repopattern(pattern):
        if pattern.endswith('**'):
            pattern = pattern[:-2]
        elif pattern.endswith('*'):
            pattern = pattern[:-1]
        if pattern.startswith('.') or pattern.find('/.') != -1:
            return False
        if pattern.find('*') != -1:
            return False
        return True
  
    confFile = os.path.join(confdir, 'config')
    conffd = open(confFile)
    p = ConfigParser.RawConfigParser()
    p.readfp(conffd)
    conffd.close()
    paths = {}
    groupdict = {}
    # set some defaults
    paths['hg-ssh']          = os.path.join(confdir, 'hg-ssh')
    paths['repopath']        = os.path.expanduser('~/repos')
    paths['htpasswdpath']    = os.path.expanduser('~/repos/htpasswd')
    paths['sshauthkeyspath'] = os.path.expanduser('~/.ssh/authorized_keys')
    for option in paths:
        if p.has_option('paths', option):
            paths[option] = os.path.expanduser(p.get('paths', option))
    paths['globalhgrc']      = os.path.join(confdir, 'hgrc')
    paths['sshkeydir']       = os.path.join(confdir, 'keys')
    for group in p.options('groups'):
        groupdict[group] = [x.strip() for x in p.get('groups', group).split(',')]
    userlist = [x.strip() for x in p.get('users', 'users').split(',')]

    accessFile = os.path.join(confdir, 'access')
    accessfd = open(accessFile)
    p = ConfigParser.RawConfigParser()
    p.readfp(accessfd)
    accessfd.close()
    accessdict = {}
    for path in p.sections():
        accessdict.setdefault(path, {})
        for userorgroup, accesstype in p.items(path):
            if userorgroup[0] == '@':
                prefix = 'group'
                realname = userorgroup[1:]
            else:
                prefix = 'user'
                realname = userorgroup
            accessdict[path].setdefault(prefix, {})
            if 'r' in accesstype:
                accessdict[path][prefix].setdefault("read", [])
                accessdict[path][prefix]["read"].append(realname)
            if 'w' in accesstype:
                accessdict[path][prefix].setdefault("write", [])
                accessdict[path][prefix]["write"].append(realname)
            if 'C' in accesstype:
                accessdict[path][prefix].setdefault("create", [])
                accessdict[path][prefix]["create"].append(realname)

    # now some sanity checks:
    for u in userlist:
        if not _valid_name(u):
            warn("User %s has invalid name" % u)
            confError = True
            userlist.remove(u)
    todelete = set()
    for g in groupdict:
        if not _valid_name(g):
            warn("Group %s has invalid name" % g)
            confError = True
            todelete.add(g)
    for g in todelete: del groupdict[g]
    for g in groupdict:
        for u in groupdict[g]:
            if not u in userlist:
                warn("Group %s refers to undefined user %s" %(g, u))
                confError = True
                groupdict[g].remove(u)
    todelete = []
    for repo in accessdict:
        if not _valid_repopattern(repo):
            warn('repo pattern %s is invalid' % repo)
            confError = True
            todelete.append(repo)
            continue
        for ug in accessdict[repo]:
            for accesstype in accessdict[repo][ug]:
                for userorgroup in accessdict[repo][ug][accesstype]:
                    debug("debug_foo:" +" "+ repo + ' ' + userorgroup +' '+ ug)
                    if ug == 'user' and not userorgroup in userlist:
                        confError = True
                        warn("repo access to %s refers to undefined user %s" %(repo, userorgroup))
                        accessdict[repo][ug][accesstype].remove(userorgroup)
                    if ug == 'group' and not userorgroup in groupdict:
                        confError = True
                        warn("repo access to %s refers to undefined group %s" %(repo, userorgroup))
                        accessdict[repo][ug][accesstype].remove(userorgroup)
    for t in todelete:
        del accessdict[t]
    retval = confobj()
    retval.userlist = userlist
    retval.groupdict = groupdict
    retval.accessdict = accessdict
    retval.paths = paths
    return retval

def replacefile(targetpath, newsuffix, backupsuffix):
    b = targetpath + backupsuffix
    n = targetpath + newsuffix
    try:
        os.remove(b)
        os.link(targetpath, b)
    except:
        pass
    try:
        os.rename(n, targetpath)
    except Exception as e:
        os.remove(n)
        raise e
    try:
        os.remove(b)
    except:
        pass

def gen_hgrc(repo):
    globalhgrcprefix = config.paths['globalhgrc']
    debug("gen_hgrc: " + repr(repo) + ' ' + repr(config))
    tmppath = repo +"/.hg/hgrc_tmp"
    tmpfile = open(tmppath, "w")
    if os.access(globalhgrcprefix, os.R_OK):
        tmpfile.write(open(globalhgrcprefix).read())
    if os.access(repo+".hg/hgrc_prefix", os.R_OK):
        tmpfile.write(open(repo+".hg/hgrc_prefix").read())
    readlist = set()
    writelist = set()
    pattern = find_matching_repopat(repo)
    for user in config.userlist:
        if allow_access_bypattern("read", user, pattern):
            readlist.add(user)
        if allow_access_bypattern("write", user, pattern):
            writelist.add(user)
            readlist.add(user)
    tmpfile.write("[web]\n")
    if len(readlist) == 0: 
        tmpfile.write("deny_read = *\n")
    else:
        tmpfile.write("allow_read = ")
        sep = ''
        for user in readlist:
            tmpfile.write(sep + user)
            sep = ', '
        tmpfile.write("\n")
    if len(writelist) == 0:
        tmpfile.write("deny_push = *\n")
    else:
        tmpfile.write("allow_push = ")
        sep = ''
        for user in writelist:
            tmpfile.write(sep + user)
            sep = ', '
        tmpfile.write("\n")
    tmpfile.close()
    replacefile(repo+"/.hg/hgrc", "_tmp", "_bak")

def fetchkey(keyfile):
    try:
        x = subprocess.Popen(["ssh-keygen", "-i", "-f", keyfile], stderr=subprocess.STDOUT)
        key = x.communicate()[0]
        if x.returncode == 0:
            return [key]
    except subprocess.CalledProcessError as e:
        pass
    try:
        return [ x.strip() for x in open(keyfile).readlines() ]
    except Exception as e:
        # raise e
        return None

def gen_authkeys():
    userlist = config.userlist
    keydir = config.paths['sshkeydir']
    authkeypath = config.paths['sshauthkeyspath']
    tmppath = authkeypath +"_tmp"
    tmpfile = open(tmppath, "w")
    for user in userlist:
        l = []
        try:
            l = os.listdir(keydir + '/' + user)
        except OSError as e:
            continue
        for keyfile in l:
            p = keydir + '/' + user + '/' + keyfile
            keylist = fetchkey(p)
            if keylist == None:
                continue
            for key in keylist:
                tmpfile.write('no-pty,no-port-forwarding,no-X11-forwarding,no-agent-forwarding,command=')
                tmpfile.write('"' +config.paths['hg-ssh'] +' ' + config.paths['repopath'] + ' '+ user + ' " ' + key + '\n')
    tmpfile.close()
    replacefile(authkeypath, "_tmp", "_bak")



def sanitize_path(unsanitized_path):
    def _split_path_rec(path):
        if path == '/':
            return []
        p1, p2 = os.path.split(path)
        return _split_path_rec(p1) + [p2]
        
    if os.sep != '/':
        fail("incompatible operating system!")

    root = os.path.abspath(config.paths['repopath']).rstrip('/')
    root = os.path.realpath(root)
    apath = os.path.abspath(unsanitized_path).rstrip('/')
    exist, tocreate = os.path.split(apath)
    real_exist = os.path.realpath(exist)
    whole_new = real_exist + '/' + tocreate
    debug("sanitizing path " + repr(unsanitized_path))
    debug("saninfo: " + repr(root) + ' ' + repr(apath) + ' ' + repr(exist) + ' ' + repr(tocreate) + ' ' + repr(real_exist) + ' ' + repr(whole_new))

    if tocreate == '':
        return (False, '')

    if not os.path.isdir(real_exist):
        return (False, '')

    if os.path.lexists(whole_new):
        return (False, '')

    if not real_exist.startswith(root):
        return (False, '')

    spl = _split_path_rec(whole_new)
    for pathpart in spl:
        if pathpart[0] == '.':
            return (False, '')
        if '"' in pathpart:
            return (False, '')

    return (True, whole_new)

def find_matching_repopat(path):
    def _patprefix(pat):
        while pat != '' and pat[len(pat)-1] in '*' + os.sep:
            pat = pat[:-1]
        return pat
        
    def _cmpbylen(a, b):
        ppa = _patprefix(a)
        ppb = _patprefix(b)
        if ppa == ppb:
            return len(a)-len(b)
        return len(ppb)-len(ppa)
    
    def _match_repopat_to_path(repopat, path):
        debug("matching repopat " + repr(repopat) + " to path " + repr(path))
        if repopat.endswith('/**'):
            prefix = repopat[:-3]
            return path.startswith(prefix)
        if repopat.endswith('/*'):
            prefix = repopat[:-2]
            if not path.startswith(prefix):
                return False
            pathsuffix = path[len(prefix):].strip('/')
            if pathsuffix == '' or '/' in pathsuffix:
                return False
            return True
        return repopat == path

    repopatlist = list(config.accessdict.keys())
    repopatlist.sort(cmp=_cmpbylen)
    debug("find_matching_repopat: repopatlist: " + repr(repopatlist) + ' path: ' + repr(path))
    touse = None
    for repopat in repopatlist:
        extended_repopat = config.paths['repopath'] + repopat
        debug("find_matching_repopat: repopat: " + repr(repopat) + " ext_rp: " + repr(extended_repopat))
        if _match_repopat_to_path(extended_repopat, path):
            if touse == None:
                touse = repopat
                break
    return touse

    
def allow_access(accesstype, user, repopath):
    pattern = find_matching_repopat(repopath)
    debug("allow_acces path: " + repr(repopath) + " user: " + repr(user) + " accesstype: " + repr(accesstype))
    if pattern == None:
        debug("allow_access: no pattern found")
        return False;
    return allow_access_bypattern(accesstype, user, pattern)

def allow_access_bypattern(accesstype, user, pattern):
    debug("allow_acces_bypattern  pattern: " + repr(pattern) + " user: " + repr(user) + " accesstype: " + repr(accesstype))
    if pattern == None:
        return False
    if not pattern in config.accessdict:
        return False
    access = config.accessdict[pattern]
    if 'user' in access:
        tocheck = access['user']
        if accesstype in tocheck and user in tocheck[accesstype]:
            return True
    if 'group' in access:
        tocheck = access['group']
        if accesstype in tocheck:
            for group in tocheck[accesstype]:
                if user in config.groupdict[group]:
                    return True
    return False

if __name__ == "__main__":
    main()
  
