#! /usr/bin/env python

import ConfigParser, string, sys, os, re, subprocess, stat, shutil, base64, logging, logging.handlers
from mercurial import ui, hg, dispatch

try:
    request = dispatch.request
except AttributeError:
    request = list 

# directory where hgadmin searches for its configuration
BASEDIR='~/hgadmin-config'

def usage(name):
    x = """usage: 
{n} [-D] [--confdir DIR] maybe_create_repo USER PATH 
  creates repository at PATH, if USER is
  allowed. PATH is relative to configured repo directory.
{n} [-D] [--confdir DIR] create_repo PATH 
  creates repository at PATH. PATH is relative to configured repo directory.
{n} [-D] [--confdir DIR] updateauth
  updates authorization information in the managed repositories,
  regenerates authorized_keys file etc
{n} [-D] [--confdir DIR] verify
  reads in configuration and verifies its correctness (giving error messages)
{n} [-D] [--confdir DIR] accesscheck ACCESSTYPE USER PATH
  prints TRUE if access ACCESSTYPE on PATH is allowed to USER, else FALSE
{n} [-D] [--confdir DIR] getpattern PATH
  prints the pattern from the configuration that matches PATH
The configuration directory defaults to "~/hgadmin", which can be overridden 
by setting the environment variable "HGADMIN-CONFREPO" or using the "--confdir" option.
The "-D" option enables the (rather verbose) debugging output.
""" 
    print(x.format(n=name))

config = None
configDir = None
confError = False
_DEBUG = False
LOGFILE = "/var/log/hgadmin/hgadmin.log"

def main():
    global config
    global configDir
    global _DEBUG
    logging.basicConfig(stream=sys.stdout, level=logging.INFO)
    try:
        logging.getLogger().addHandler(logging.handlers.RotatingFileHandler(LOGFILE, maxBytes=100000, backupCount=10))
    except IOError as e:
        warn('unable to open log file ' + repr(LOGFILE))
    x = BASEDIR
    x = os.getenv("HGADMIN-CONFREPO", x)
    foundArg = True
    while foundArg:
        foundArg = False
        if len(sys.argv) >= 3 and sys.argv[1] == "--confdir":
            x = sys.argv[2]
            del sys.argv[2]
            del sys.argv[1]
            foundArg = True
            continue
        if len(sys.argv) >= 2 and sys.argv[1] == "-D":
            _DEBUG = True
            logging.getLogger().setLevel(logging.DEBUG)
            foundArg = True
            del sys.argv[1]
            continue
    configDir = os.path.abspath(os.path.expanduser(x))
    config = parse_config(configDir)
    debug("config: "+ repr(config))
    if len(sys.argv) == 4 and sys.argv[1] == "maybe_create_repo":
        gen_repo(sys.argv[2], sys.argv[3])
        exit(0)
    if len(sys.argv) == 3 and sys.argv[1] == "create_repo":
        path_ok, sane_path = sanitize_path(sys.argv[2])
        if not path_ok:
            fail("invalid path: " + repr(sys.argv[2]) + " " + repr(sane_path))
        gen_repo_nocheck(sane_path)
        exit(0)
    elif len(sys.argv) == 2 and sys.argv[1] == "updateauth":
        update_auth()
        exit(0)
    elif len(sys.argv) == 2 and sys.argv[1] == "verify":
        if confError:
            exit(1)
        exit(0)
    elif len(sys.argv) == 5 and sys.argv[1] == "accesscheck":
        flag, p = sanitize_path(sys.argv[4])
        repopatlist = find_matching_repopatterns(p)
        if flag:
            print allow_access(sys.argv[2], sys.argv[3], repopatlist)
        else:
            print False
        exit(0)  
    elif len(sys.argv) == 3 and sys.argv[1] == "getpattern":
        flag, p = sanitize_path(sys.argv[2])
        if flag:
            print repr(find_matching_repopatterns(p))
        else:
            print False
        exit(0)  
    else:
        usage(sys.argv[0])
        exit(1)

def fail(msg):
    logging.error(msg)
    print "failure:", msg
    exit(1)


def debug(msg):
    logging.debug(msg)

def warn(msg):
    logging.warning(msg)

def info(msg):
    logging.info(msg)

def closefd(fd):
    fd.flush()
    os.fsync(fd.fileno())
    fd.close()

def gen_repo_nocheck(sane_path):
    dispatch.dispatch(request(['init', sane_path]))
    x = open(sane_path+'/.hg/hgrc_prefix', "w")
    x.write("\n# hgrc_prefix is the repository - local static configuration file\n")
    x.write("# here, you can put configuration stuff (like email notification etc.\n") 
    x.write("# that you do not want overwritten automatically\n")
    x.write("# Note that you must not include a [web] section in here!\n\n")
    x.close()
    gen_hgrc(sane_path)
    x = open(sane_path+'/.hg/ADMINISTRATED_BY_HGADMIN', "w")
    x.write("foo")
    closefd(x)
    info("created repo at " + repr(sane_path))
    

def gen_repo(user, unsanitized_repopath):
    path_ok, sane_path = sanitize_path(unsanitized_repopath)
    if not path_ok:
        fail("invalid path")
    if not user in config.userlist:
        fail("unknown user")
    repopatlist = find_matching_repopatterns(sane_path)
    if not allow_access("create", user, repopatlist):
        fail("access denied")
    gen_repo_nocheck(sane_path)

def update_auth():
    repolist = list_all_repos()
    for repo in repolist:
        gen_hgrc(repo)
    gen_authkeys()
    update_htaccess()
    info("updated access and authentication, config repo at " + os.getenv("HG_NODE", "unknown"))

def list_all_repos():
    repolist = []
    f = config.paths['repopath']
    for root, dirs, files in os.walk(f, topdown=True):
        debug("walking: " + repr(root))
        if is_managed_repo(root, isAbs=True):
            debug("found: " + repr(root))
            repolist.append(root)
        if '.hg' in dirs: 
            dirs.remove('.hg')
    debug("all repos: " + repr(repolist))
    return repolist

def is_managed_repo(repo, isAbs=False):
    if isAbs:
        repopath = repo
    else:
        root = config.paths['repopath']
        repopath = root + '/' + repo
    x = os.access(repopath + '/.hg/ADMINISTRATED_BY_HGADMIN', os.F_OK)
    debug("is_managed_repopath" + repr(repopath) + " : " + repr(x))
    return x

class confobj: # object to save configuration settings
    def __init__(self):
        self.userlist = None
        self.groupdict = None
        self.accessdict = None
        self.paths = None
    def __repr__(self):
        return "config:\n" \
            + "  userlist: "   + repr(self.userlist) + "\n" \
            + "  groupdict: "  + repr(self.groupdict) + "\n" \
            + "  accessdict: " + repr(self.accessdict) + "\n" \
            + "  paths: "      + repr(self.paths) + "\n" 


def parse_config(confdir):
    global confError

    def _valid_name(name):
        validchars = string.letters + string.digits + '_-+&'
        for c in name:
            if not c in validchars:
                return False
        if len(name) == 0:
            return False
        return True
    
    def _valid_repopattern(pattern):
        if pattern.endswith('**'):
            pattern = pattern[:-2]
        elif pattern.endswith('*'):
            pattern = pattern[:-1]
        if pattern.startswith('.') or pattern.find('/.') != -1:
            return False
        if pattern.find('*') != -1:
            return False
        return True

    def _splitoption(option):
        #debug("option: " + repr(option))
        option_woc = re.sub(r"#[^\n]*", "", option)
        #debug("option: " + repr(option_woc))
        option_notc = option_woc.rstrip().rstrip(',')
        #debug("option: " + repr(option_notc))
        option_split =  option_notc.split(',') 
        #debug("option: " + repr(option_split))
        option_retlist =  [ x.strip() for x in option_split if x.strip() != '' ]
        #debug("option: " + repr(option_retlist))
        return sorted(option_retlist)

    confFile = os.path.join(confdir, 'config')
    accessFile = os.path.join(confdir, 'access')
    try:
        accessfd = open(accessFile)
        conffd = open(confFile)
        configContent = ConfigParser.RawConfigParser()
        configContent.readfp(conffd)
        accessContent = ConfigParser.RawConfigParser()
        accessContent.readfp(accessfd)
        conffd.close()
        accessfd.close()
    except IOError as e:
        fail("unable to read configuration files")
    paths = {}
    groupdict = {}
    # do not set defaults...
    # paths['hg-ssh']          = os.path.join(confdir, 'hg-ssh')
    # paths['repopath']        = os.path.expanduser('~/repos')
    # paths['htpasswdpath']    = os.path.expanduser('~/repos/htpasswd')
    # paths['sshauthkeyspath'] = os.path.expanduser('~/.ssh/authorized_keys')
    for option in ['hg-ssh', 'repopath', 'htpasswdpath', 'sshauthkeyspath']:
        if configContent.has_option('paths', option):
            paths[option] = os.path.expanduser(configContent.get('paths', option))
    if not 'repopath' in paths:
        usage(sys.argv[0])
        fail("configuration variable 'repopath' not set")
    paths['confdir']         = confdir
    paths['globalhgrc']      = os.path.join(confdir, 'hgrc')
    paths['globalhgrc_web']  = os.path.join(confdir, 'hgrc_web')
    paths['sshkeydir']       = os.path.join(confdir, 'keys')
    paths['managedhtpwd']    = os.path.join(confdir, 'htpasswd')
    for group in configContent.options('groups'):
        groupdict[group] = _splitoption(configContent.get('groups', group)) 
    userlist = _splitoption(configContent.get('users', 'users'))

    accessdict = {}
    for path in accessContent.sections():
        accessdict.setdefault(path, {})
        for prefix in ['user', 'group']:
            accessdict[path].setdefault(prefix, {})
            for accesstype in ["read", "write", "create", "deny"]:
                accessdict[path][prefix].setdefault(accesstype, [])
        for userorgroup, accesstype in accessContent.items(path):
            if userorgroup[0] == '@':
                prefix = 'group'
                realname = userorgroup[1:]
            else:
                prefix = 'user'
                realname = userorgroup
            if 'r' in accesstype:
                accessdict[path][prefix]["read"].append(realname)
            if 'w' in accesstype:
                accessdict[path][prefix]["write"].append(realname)
                accessdict[path][prefix]["read"].append(realname)
            if 'C' in accesstype:
                accessdict[path][prefix]["create"].append(realname)
                accessdict[path][prefix]["write"].append(realname)
                accessdict[path][prefix]["read"].append(realname)
            if accesstype.strip() == '':
                accessdict[path][prefix]["deny"].append(realname)
    # now some sanity checks:
    for u in userlist:
        if not _valid_name(u):
            warn("User %s has invalid name" % u)
            confError = True
            userlist.remove(u)
    todelete = set()
    for g in groupdict:
        if not _valid_name(g):
            warn("Group %s has invalid name" % g)
            confError = True
            todelete.add(g)
    for g in todelete: del groupdict[g]
    for g in groupdict:
        for u in groupdict[g]:
            if not u in userlist:
                warn("Group %s refers to undefined user %s" %(g, u))
                confError = True
                groupdict[g].remove(u)
    todelete = []
    for repo in accessdict:
        if not _valid_repopattern(repo):
            warn('repo pattern %s is invalid' % repo)
            confError = True
            todelete.append(repo)
            continue
        for ug in accessdict[repo]:
            for accesstype in accessdict[repo][ug]:
                for userorgroup in accessdict[repo][ug][accesstype]:
                    # debug("debug_foo:" +" "+ repo + ' ' + userorgroup +' '+ ug)
                    if ug == 'user' and not userorgroup in userlist:
                        confError = True
                        warn("repo access to %s refers to undefined user %s" %(repo, userorgroup))
                        accessdict[repo][ug][accesstype].remove(userorgroup)
                    if ug == 'group' and not userorgroup in groupdict:
                        confError = True
                        warn("repo access to %s refers to undefined group %s" %(repo, userorgroup))
                        accessdict[repo][ug][accesstype].remove(userorgroup)
    for t in todelete:
        del accessdict[t]
    retval = confobj()
    retval.userlist = userlist
    retval.groupdict = groupdict
    retval.accessdict = accessdict
    retval.paths = paths
    return retval

def replacefile(targetpath, newsuffix, backupsuffix):
    b = targetpath + backupsuffix
    n = targetpath + newsuffix
    try:
        os.remove(b)
    except Exception as e:
        pass
    try:
        os.link(targetpath, b)
    except Exception as e:
        warn("backing up %s didn't work" % targetpath)
    try:
        os.rename(n, targetpath)
    except Exception as e:
        os.remove(n)
        raise e
    try:
        os.remove(b)
    except:
        warn("removing backupfile %s didn't work" % b)

def gen_hgrc(repo):
    globalhgrcprefix = config.paths['globalhgrc']
    debug("gen_hgrc: " + repr(repo))
    tmppath = repo +"/.hg/hgrc_tmp"
    tmpfile = open(tmppath, "w")
    if os.access(globalhgrcprefix, os.R_OK):
        tmpfile.write("\n%include " + globalhgrcprefix)
    if os.access(repo+"/.hg/hgrc_prefix", os.R_OK):
        tmpfile.write("\n%include " + repo+"/.hg/hgrc_prefix")
    tmpfile.write("\n\n[web]\n")
    tmpfile.write("%unset deny_read\n")
    tmpfile.write("%unset deny_push\n")
    tmpfile.write("%unset allow_read\n")
    tmpfile.write("%unset allow_push\n")
    readlist = set()
    writelist = set()
    repopatlist = find_matching_repopatterns(repo)
    for user in config.userlist:
        if allow_access("read", user, repopatlist):
            readlist.add(user)
        if allow_access("write", user, repopatlist):
            writelist.add(user)
            readlist.add(user)
    if len(readlist) == 0: 
        tmpfile.write("deny_read = *\n")
    else:
        tmpfile.write("allow_read = ")
        sep = ''
        for user in readlist:
            tmpfile.write(sep + user)
            sep = ', '
        tmpfile.write("\n")
    if len(writelist) == 0:
        tmpfile.write("deny_push = *\n")
    else:
        tmpfile.write("allow_push = ")
        sep = ''
        for user in writelist:
            tmpfile.write(sep + user)
            sep = ', '
        tmpfile.write("\n")
    closefd(tmpfile)
    replacefile(repo+"/.hg/hgrc", "_tmp", "_bak")

def valid_sshkey(x):
    try:
        xs = x.split()
        if len(xs) != 3:
            return False
        keytype, keystring, comment = xs
        keydata = base64.decodestring(key_string)
        str_len = struct.unpack('>I', data[:4])[0]
        return keydata[4:4+str_len] == keytype
    except Exception as e:
        return False

def fetchkey(keyfile):
    try:
        x = subprocess.Popen(["ssh-keygen", "-i", "-f", keyfile], 
                             stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        key = x.stdout.read()
        if x.returncode == 0:
            return [key]
    except subprocess.CalledProcessError as e:
        pass
    keylist = None
    try:
        keylist =  [ x.strip() for x in open(keyfile).readlines() ]
        for l in keylist:
            if not valid_sshkey(l):
                warning("keyfile " + repr(keyfile) + " contains stuff that does not seem like a ssh key, ignoring this file")
                return None
    except Exception as e:
        # raise e
        pass
    return keylist

def gen_authkeys():
    if not ('sshauthkeyspath' in config.paths and 'hg-ssh' in config.paths):
        info("required configuration settings for authkeyfile generation missing; skipping generation")
        return
    userlist = config.userlist
    keydir = config.paths['sshkeydir']
    authkeypath = config.paths['sshauthkeyspath']
    tmppath = authkeypath +"_tmp"
    predefpath = authkeypath +"_const"
    os.umask(077)
    tmpfile = open(tmppath, "w")
    try: 
        predef = open(predefpath, "r")
        x = os.fstat(predef.fileno())
        # read predef file only if not writeable by others
        if x.st_mode & (stat.S_IWOTH | stat.S_IWGRP) == 0:
            tmpfile.write(predef.read())
        predef.close()
    except IOError as e:
        pass
    for user in userlist:
        l = []
        try:
            l = os.listdir(keydir + '/' + user)
        except OSError as e:
            continue
        debug("gen_authkeys: for user " + user + " using keyfiles " + repr(l))
        for keyfile in l:
            p = keydir + '/' + user + '/' + keyfile
            keylist = fetchkey(p)
            if keylist == None:
                continue
            for key in keylist:
                tmpfile.write('no-pty,no-port-forwarding,no-X11-forwarding,no-agent-forwarding,command=')
                tmpfile.write('"' +config.paths['hg-ssh'] +' ' + config.paths['repopath'] + ' '+ user + ' ' + configDir + ' " ' + key + '\n')
    closefd(tmpfile)
    
    replacefile(authkeypath, "_tmp", "_bak")

def update_htaccess():
    if not 'htpasswdpath' in config.paths:
        info("config setting 'htpasswdpath' missing; skipping update of htpasswd file")
        return
    tochange = config.paths['htpasswdpath']
    newfile = config.paths['managedhtpwd']
    if os.path.exists(newfile):
        os.umask(033)
        x = open(tochange+"_tmp", "w")
        x.write(open(newfile, "r").read())
        closefd(x)
        replacefile(tochange, "_tmp", "_bak")



def sanitize_path(unsanitized_path):
    def _split_path_rec(path):
        if path == '/':
            return []
        p1, p2 = os.path.split(path)
        return _split_path_rec(p1) + [p2]
        
    if os.sep != '/':
        fail("incompatible operating system!")

    root = os.path.abspath(config.paths['repopath']).rstrip('/')
    root = os.path.realpath(root)
    apath = os.path.abspath(unsanitized_path).rstrip('/')
    exist, tocreate = os.path.split(apath)
    real_exist = os.path.realpath(exist)
    whole_new = real_exist + '/' + tocreate
    debug("sanitizing path " + repr(unsanitized_path))
    debug("saninfo: " + repr(root) + ' ' + repr(apath) + ' ' + repr(exist) + ' ' + repr(tocreate) + ' ' + repr(real_exist) + ' ' + repr(whole_new))

    if tocreate == '':
        return (False, '')

    if not os.path.isdir(real_exist):
        return (False, '')

    if os.path.lexists(whole_new):
        return (False, '')

    if not real_exist.startswith(root):
        return (False, '')

    spl = _split_path_rec(whole_new)
    for pathpart in spl:
        if pathpart[0] == '.':
            return (False, '')
        if '"' in pathpart:
            return (False, '')

    return (True, whole_new)

def find_matching_repopatterns(path):
    def _patprefix(pat):
        while pat != '' and pat[len(pat)-1] in '*' + os.sep:
            pat = pat[:-1]
        return pat
        
    def _cmpbylen(a, b):
        ppa = _patprefix(a)
        ppb = _patprefix(b)
        if ppa == ppb:
            return len(a)-len(b)
        return len(ppb)-len(ppa)
    
    def _match_repopat_to_path(repopat, path):
        # debug("matching repopat " + repr(repopat) + " to path " + repr(path))
        if repopat.endswith('/**'):
            prefix = repopat[:-3]
            return path.startswith(prefix)
        if repopat.endswith('/*'):
            prefix = repopat[:-2]
            if not path.startswith(prefix):
                return False
            pathsuffix = path[len(prefix):].strip('/')
            if pathsuffix == '' or '/' in pathsuffix:
                return False
            return True
        return repopat == path

    repopatlist = list(config.accessdict.keys())
    repopatlist.sort(cmp=_cmpbylen)
    # debug("find_matching_repopatterns: repopatlist: " + repr(repopatlist) + ' path: ' + repr(path))
    retlist = []
    for repopat in repopatlist:
        extended_repopat = os.path.normpath(config.paths['repopath'] + repopat)
        # debug("find_matching_repopatterns: repopat: " + repr(repopat) + " ext_rp: " + repr(extended_repopat))
        if _match_repopat_to_path(extended_repopat, path):
            retlist.append(repopat)
    retlist.sort(cmp=_cmpbylen)
    debug("find_matching_repopatterns: path " + repr(path) + " found " + repr(retlist))
    return retlist

    
def allow_access(accesstype, user, patterns):
    debug("allow_access patterns: " + repr(patterns) + " user: " + repr(user) + " accesstype: " + repr(accesstype))
    for p in patterns:
        if user in config.accessdict[p]['user'][accesstype]:
            debug("allow_access: Success, pattern: " + repr(p))
            return True
        glist = [ x for x,y in config.groupdict.items() if user in y ]
        for g in glist:
            if g in config.accessdict[p]['group'][accesstype]:
                debug("allow_access: Success, pattern: " + repr(p))
                return True
        for g in glist:
            for at in config.accessdict[p]['group']:
                if g in config.accessdict[p]['group'][at]:
                    debug("allow_access: Failure, pattern: " + repr(p))
                    return False
        for at in config.accessdict[p]['user']:
            if user in config.accessdict[p]['user'][at]:
                debug("allow_access: Failure, pattern: " + repr(p))
                return False
    debug("allow_access: Failure, no pattern")
    return False

if __name__ == "__main__":
    main()
  
