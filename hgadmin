#! /usr/bin/env python

import ConfigParser, string, sys, os, re
from mercurial import ui, hg, dispatch

try:
    request = dispatch.request
except AttributeError:
    request = list 

# directory where hgadmin searches for its configuration
BASEDIR='~/hgadmin'

def usage(name):
    print """usage: 
%s mkrepo USER PATH 
  creates repository at PATH, if USER is
  allowed. PATH is relative to configured repo directory.
%s updateauth
  updates authorization information in the managed repositories,
  regenerates authorized_keys file etc
""" % (name, name)

config = None

def main():
    config = parse_config(os.path.expanduser(BASEDIR))
    print repr(config)
    if len(sys.argv) == 4 and sys.argv[1] == "mkrepo":
        gen_repo(sys.argv[2], sys.argv[3])
        exit(0)
    elif len(sys.argv) == 2 and sys.argv[1] == "updateauth":
        update_auth()
        exit(0)
    else:
        usage(sys.argv[0])
        exit(1)

def fail(message):
    message(message, "failure")
    exit(1)

def message(message, messagelevel="info"):
    print messagelevel, ":", message

def debug(msg):
    message(msg, "debug")

def warn(msg):
    message(msg, "warning")

def gen_repo(user, unsanitized_repopath):
    path_ok, sanitized_path = sanitize_path(unsanitized_repopath)
    if not path_ok:
        fail("invalid path")
    if not user in config['userlist']:
        fail("unknown user")
    if not allow_access("create", user, sanitized_path):
        fail("access denied")
    dispatch.dispatch(request(['init', sanitized_path]))
    gen_hgrc(sanitized_path)
    x = open(sanitized_path+'/.hg/ADMINISTRATED_BY_HGADMIN', "w")
    x.write("foo")
    x.close()
    debug("now creating repo at " + repr(sanitized_path))

def update_auth():
    repolist = list_all_repos()
    for repo in repolist:
        gen_hgrc(repo)
    gen_authkeys()
    gen_htaccess()

def list_all_repos():
    repolist = []
    for root, dirs, files in os.walk(config['confdict']['repopath'], topdown=True):
        if is_managed_repo(root):
            repolist.append(root)
        if '.hg' in dirs: 
            dirs.remove('.hg')
    return repolist

def is_managed_repo(repo):
    root = config['confdict']['repopath']
    repopath = root + '/' + repopath
    if not os.access(repopath + '/.hg/ADMINISTRATED_BY_HGADMIN', os.F_OK):
        return False
    return True


def parse_config(confdir):
    def valid_name(name):
        validchars = string.letters + string.digits + '_-+&'
        for c in name:
            if not c in validchars:
                return False
        return True
    
    def valid_repopath(repo):
        if not repo.startswith(os.sep):
            return False
        if repo.endswith('**'):
            repo = repo[:-2]
        elif repo.endswith('*'):
            repo = repo[:-1]
        if repo.find('*') != -1:
            return False
        if repo.find(os.sep + '.hg' + os.sep) != -1:
            return False
        if repo.endswith(os.sep + '.hg'):
            return False
        return True
  
    confFile = os.path.join(confdir, 'config')
    conffd = open(confFile)
    p = ConfigParser.RawConfigParser()
    p.readfp(conffd)
    conffd.close()
    confdict = {}
    groupdict = {}
    for option in ['repopath', 'htpasswdpath', 'sshauthkeyspath', 'globalhgrc', 'sshkeydir']:
        confdict[option] = os.path.expanduser(p.get('paths', option))
    for group in p.options('groups'):
        groupdict[group] = [x.strip() for x in p.get('groups', group).split(',')]
    userlist = [x.strip() for x in p.get('users', 'users').split(',')]

    accessFile = os.path.join(confdir, 'access')
    accessfd = open(accessFile)
    p = ConfigParser.RawConfigParser()
    p.readfp(accessfd)
    accessfd.close()
    accessdict = {}
    for path in p.sections():
        accessdict.setdefault(path, {})
        for userorgroup, accesstype in p.items(path):
            if userorgroup[0] == '@':
                prefix = 'group'
                realname = userorgroup[1:]
            else:
                prefix = 'user'
                realname = userorgroup
            accessdict[path].setdefault(prefix, {})
            if 'r' in accesstype:
                accessdict[path][prefix].setdefault("read", [])
                accessdict[path][prefix]["read"].append(realname)
            if 'w' in accesstype:
                accessdict[path][prefix].setdefault("write", [])
                accessdict[path][prefix]["write"].append(realname)
            if 'C' in accesstype:
                accessdict[path][prefix].setdefault("create", [])
                accessdict[path][prefix]["create"].append(realname)

    # now some sanity checks:
    for u in userlist:
        if not valid_name(u):
            warn("User %s has invalid name" % u)
            userlist.remove(u)
    todelete = set()
    for g in groupdict:
        if not valid_name(g):
            warn("Group %s has invalid name" % g)
            todelete.add(g)
    for g in todelete: del groupdict[g]
    for g in groupdict:
        for u in groupdict[g]:
            if not u in userlist:
                warn("Group %s refers to undefined user %s" %(g, u))
                groupdict[g].remove(u)
    todelete = []
    for repo in accessdict:
        if not valid_repopath(repo):
            warn('repo path %s is invalid' % repo)
            todelete.append(repo)
            continue
        for ug in accessdict[repo]:
            for accesstype in accessdict[repo][ug]:
                for userorgroup in accessdict[repo][ug][accesstype]:
                    debug("debug_foo:" +" "+ repo + ' ' + userorgroup +' '+ ug)
                    if ug == 'user' and not userorgroup in userlist:
                        warn("repo access to %s refers to undefined user %s" %(repo, userorgroup))
                        accessdict[repo][ug][accesstype].remove(userorgroup)
                    if ug == 'group' and not userorgroup in groupdict:
                        warn("repo access to %s refers to undefined group %s" %(repo, userorgroup))
                        accessdict[repo][ug][accesstype].remove(userorgroup)
    for t in todelete:
        del accessdict[t]
    retval = { "userlist": userlist, "groupdict": groupdict, "accessdict": accessdict, "confdict": confdict } 
    return retval

def replacefile(targetpath, newsuffix, backupsuffix):
    b = targetpath + backupsuffix
    n = targetpath + newsuffix
    try:
        os.remove(b)
        os.link(targetpath, b)
    except:
        pass
    try:
        os.rename(n, targetpath)
    except Exception as e:
        os.remove(n)
        raise e
    try:
        os.remove(b)
    except:
        pass

def gen_hgrc(repo):
    config = confdict
    accessdict =  config['groupdict']
    groupdict= config['accessdict']
    userlist =  config['userlist']
    globalhgrcprefix = config['confdict']['globalhgrc']
    debug("gen_hgrc" + repo + ' ' + accessdict +' '+ groupdict+' '+ userlist+' '+ globalhgrcprefix)
    tmppath = repo +"/.hg/hgrc_tmp"
    tmpfile = open(tmppath, "w")
    if os.access(globalhgrcprefix, os.R_OK):
        tmpfile.write(open(globalhgrcprefix).read())
    if os.access(repo+".hg/hgrc_prefix", os.R_OK):
        tmpfile.write(open(repo+".hg/hgrc_prefix").read())
    readlist = set()
    writelist = set()
    for user in userlist:
        if allow_access("read", user, repo, accessdict, groupdict):
            readlist.add(user)
        if allow_access("write", user, repo, accessdict, groupdict):
            writelist.add(user)
            readlist.add(user)
    tmpfile.write("[web]\n")
    tmpfile.write("allow_read = ")
    sep = ''
    for user in readlist:
        tmpfile.write(sep + user)
        sep = ', '
    tmpfile.write("\n")
    tmpfile.write("allow_write = ")
    sep = ''
    for user in writelist:
        tmpfile.write(sep + user)
        sep = ', '
    tmpfile.write("\n")
    tmpfile.close()
    replacefile(repo+"/.hg/hgrc", "_tmp", "_bak")

def fetchkey(keyfile):
    try:
        key = subprocess.check_output(["ssh-keygen", "-i", "-f", keyfile])
        return [key]
    except subprocess.CalledProcessError as e:
        pass
    try:
        return [ x.strip() for x in open(keyfile).readlines() ]
    except Exception as e:
        # raise e
        return None

def gen_authkeys():
    userlist = config['userlist']
    keydir = config['confdict']['sshkeydir']
    authkeypath = config['confdict']['sshauthkeyspath']
    tmppath = authkeypath +"_tmp"
    tmpfile = open(tmppath, "w")
    for user in userlist:
        l = []
        try:
            l = os.listdir(keydir + '/' + user)
        except OSError as e:
            continue
        for keyfile in l:
            p = keydir + '/' + user + '/' + keyfile
            keylist = fetchkey(p)
            if keylist == None:
                continue
            for key in keylist:
                tmpfile.write('no-pty,no-port-forwarding,no-X11-forwarding,no-agent-forwarding,command=')
                tmpfile.write('"sshwrapper ' + user + ' " ' + key + '\n')
    tmpfile.close()
    replacefile(authkeypath, "_tmp", "_bak")



def sanitize_path(unsanitized_path):
    def split_path_rec(path):
        if path == '/':
            return []
        p1, p2 = os.path.split(path)
        return split_path_rec(p1) + [p2]
        
    if os.sep != '/':
        fail("incompatible operating system!")

    root = os.path.abspath(config['confdict']['reporoot']).rstrip('/')
    apath = os.path.abspath(root + '/' + unsanitized_path).rstrip('/')
    exist, tocreate = os.path.split(apath)
    real_exist = os.path.realname(exist)
    whole_new = real_exist + '/' + tocreate

    if tocreate == '':
        return (False, '')

    if not os.path.isdir(real_exist):
        return (False, '')

    if os.path.lexists(whole_new):
        return (False, '')

    if not real_exist.startswith(root):
        return (False, '')

    spl = split_path_rec(whole_new)
    for pathpart in spl:
        if pathpar[0] == '.':
            return (False, '')
        if '"' in pathpart:
            return (False, '')

    return (True, whole_new)

def find_matching_repopat(path):
    def _patprefix(pat):
        while pat != '' and pat[len(pat)-1] in '*' + os.sep:
            pat = pat[:-1]
        return pat
        
    def _cmpbylen(a, b):
        ppa = _patprefix(a)
        ppb = _patprefix(b)
        if ppa == ppb:
            return len(a)-len(b)
        return len(ppb)-len(ppa)
    
    def _match_repopat_to_path(repopat, path):
        prefix = _patprefix(repopat)
        if repopat.endswith('**'):
            return path.startswith(prefix)
        if repopat.endswith('*'):
            if not path.startswith(prefix):
                return False
            if os.sep in path[len(repopat)-1:]:
                return False
            return True
        return repopat == path

    repopatlist = list(config['accessdict'].keys())
    repopatlist.sort(cmp=_cmpbylen)
    touse = None
    for repopat in repopatlist:
        if _match_repopat_to_path(repopat, path):
            if touse == None:
                touse = repopat
        else:
            pass
    return touse

    
def allow_access(accesstype, user, repopath):
    pattern = find_matching_repopat(repopath)
    access = config['accessdict'][pattern]
    if 'user' in access:
        tocheck = access['user']
        if accesstype in tocheck and user in tocheck[accesstype]:
            return True
    if 'group' in access:
        tocheck = access['group']
        if accesstype in tocheck:
            for group in tocheck[accesstype]:
                if user in config['groupdict'][group]:
                    return True
    return False

if __name__ == "__main__":
    main()
  
